package watcher

import (
	"context"
	"fmt"
	"time"

	"github.com/go-logr/logr"
	"github.com/nordix/meridio/pkg/log"
	"github.com/nordix/meridio/pkg/retry"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/watch"
)

// ObjectMonitor -
// Watches a particular kubernetes object through k8s API
type ObjectMonitor struct {
	name      string
	namespace string
	object    WatchObject
	watcher   watch.Interface
	handler   WatchEventHandler
	logger    logr.Logger
}

// NewObjectMonitor -
// param name: name of the k8s object to monitor
// param namespace: namespace of the object to monitor
// param create: func that creates the specific type of k8s object for monitoring purposes (e.g. v1.SecretInterface)
// param handler: handles watch events generated by the monitor
func NewObjectMonitor(ctx context.Context, name string, namespace string, handler WatchEventHandler, create CreateWatchObject) (*ObjectMonitor, error) {
	object, err := create(namespace)
	if err != nil {
		return nil, fmt.Errorf("init object %v (namespace=%v) error: %v", name, namespace, err)
	}

	monitor := &ObjectMonitor{
		name:      name,
		namespace: namespace,
		handler:   handler,
		object:    object,
		logger:    log.FromContextOrGlobal(ctx).WithValues("class", "ObjectMonitor", "instance", fmt.Sprintf("%v %v", name, namespace)),
	}
	return monitor, nil
}

// Start -
// Starts monitoring the object, and relays events to handler
// Note: blocks caller
func (om *ObjectMonitor) Start(ctx context.Context) {
	err := retry.Do(func() error {
		om.logger.V(1).Info("Start")
		var err error
		objectMeta := metav1.ObjectMeta{Name: om.name, Namespace: om.namespace}
		om.watcher, err = om.object.Watch(ctx, metav1.SingleObject(objectMeta))
		if err != nil {
			om.logger.Error(err, "Unable to watch")
			return fmt.Errorf("failed to watch (%s): %w", objectMeta.String(), err)
		}
		om.watchEvent(ctx, om.watcher.ResultChan())
		return nil
	}, retry.WithContext(ctx),
		retry.WithDelay(500*time.Millisecond),
		retry.WithErrorIngnored())
	if err != nil {
		om.logger.Error(err, "Start")
	}
}

// Stop -
// Stops the object monitor, and signals event handler
func (om *ObjectMonitor) Stop(ctx context.Context) {
	om.logger.V(1).Info("Stop")
	if om.watcher != nil {
		om.watcher.Stop()
	}
	om.handler.End(ctx, om.namespace, om.name)
}

func (om *ObjectMonitor) watchEvent(ctx context.Context, eventChannel <-chan watch.Event) {
	for {
		select {
		case event, open := <-eventChannel:
			if open {
				// inform watch event handler
				om.handler.Handle(ctx, &event)
			} else {
				om.logger.V(1).Info("Event channel closed")
				return
			}
		case <-ctx.Done():
		}
	}
}
