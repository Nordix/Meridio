/*
Copyright (c) 2023 Nordix Foundation

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package interfacename

import (
	"context"
	"sync"
	"time"

	"github.com/go-logr/logr"
	"github.com/nordix/meridio/pkg/log"
)

const defaultReleaseTimeout = 60 * time.Second

type ReleaseTrigger func() <-chan struct{}

// InterfaceNameChache -
// InterfaceNameChache keeps track of interface names
// generated by NameGenerator and links them to IDs.
//
// Uses a delayed release functionality, so that the same
// interface name could be recovered within release timeout
// for a particular ID. Thus avoiding interface name change
// upon NSM heal with reselect.
type InterfaceNameChache struct {
	nameGenerator  NameGenerator
	interfaceNames map[string]*interfaceName // key: id, value: name
	releaseTrigger ReleaseTrigger
	logger         logr.Logger
	ctx            context.Context
	mu             sync.Mutex
}

type interfaceName struct {
	cancelRelease context.CancelFunc
	name          string
}

// Option is an option pattern for InterfaceNameChache
type Option func(*InterfaceNameChache)

// WithReleaseTrigger sets releaseTrigger for InterfaceNameChache
func WithReleaseTrigger(trigger ReleaseTrigger) Option {
	return func(inc *InterfaceNameChache) {
		inc.releaseTrigger = trigger
	}
}

// InterfaceNameChache -
// Instantiates a new InterfaceNameChache.
func NewInterfaceNameChache(ctx context.Context, generator NameGenerator, options ...Option) *InterfaceNameChache {
	cache := &InterfaceNameChache{
		nameGenerator:  generator,
		interfaceNames: map[string]*interfaceName{},
		releaseTrigger: func() <-chan struct{} {
			channel := make(chan struct{}, 1)
			go func() {
				select {
				case <-ctx.Done():
				case <-time.After(defaultReleaseTimeout):
					channel <- struct{}{}
				}
			}()
			return channel
		},
		logger: log.FromContextOrGlobal(ctx).WithValues("class", "InterfaceNameChache"),
		ctx:    ctx,
	}

	for _, opt := range options {
		opt(cache)
	}

	return cache
}

// Generate -
// Returns interface name from cache if it already exists.
// Or generates a new one and stores it in the cache.
func (inc *InterfaceNameChache) Generate(id string, namePrefix string, maxLength int) string {
	inc.mu.Lock()
	defer inc.mu.Unlock()

	logger := inc.logger.WithValues("func", "Generate")
	cachedInterfaceName, exists := inc.interfaceNames[id]
	if exists {
		if cachedInterfaceName.cancelRelease != nil {
			logger.Info("Cancel pending release", "ID", id, "interface", cachedInterfaceName.name)
			cachedInterfaceName.cancelRelease()
			cachedInterfaceName.cancelRelease = nil
		}
		logger.V(1).Info("Return interface name from cache", "ID", id, "interface", cachedInterfaceName.name)
		return cachedInterfaceName.name
	}

	name := inc.nameGenerator.Generate(namePrefix, maxLength)
	inc.interfaceNames[id] = &interfaceName{name: name}
	logger.Info("New interface name", "ID", id, "interface", name)

	return name
}

// Release -
// Schedules delayed release of interface name associated
// with ID.
// Removal can be cancelled if re-added within the imeout.
func (inc *InterfaceNameChache) Release(id string) {
	inc.mu.Lock()
	defer inc.mu.Unlock()

	logger := inc.logger.WithValues("func", "Release")
	cachedInterfaceName, exists := inc.interfaceNames[id]
	if !exists {
		logger.Info("No interface name in cache", "ID", id)
		return
	}
	if cachedInterfaceName.cancelRelease != nil {
		logger.Info("Release already scheduled", "ID", id)
		return
	}
	cancelCtx, cancelRelease := context.WithCancel(inc.ctx)
	cachedInterfaceName.cancelRelease = cancelRelease
	name := cachedInterfaceName.name

	select {
	case <-inc.releaseTrigger():
		// release immediately
		inc.release(cancelCtx, id, name)
	default:
		// start delayed release
		go func() {
			logger.Info("Schedule release of interface name", "ID", id, "interface", name)
			inc.pendingRelease(cancelCtx, id, name)
		}()
	}
}

func (inc *InterfaceNameChache) pendingRelease(ctx context.Context, id string, name string) {
	logger := inc.logger.WithValues("func", "pendingRelease")
	select {
	case <-inc.releaseTrigger():
		// ID not re-added before delayed deletion is triggered
		inc.mu.Lock()
		inc.release(ctx, id, name)
		inc.mu.Unlock()
	case <-ctx.Done():
		// cancel to keep interface name associated with ID in cache
		logger.Info("Release cancelled", "ID", id, "interface", name)
		return
	}
}

// must be called with lock held
func (inc *InterfaceNameChache) release(ctx context.Context, id string, name string) {
	logger := inc.logger.WithValues("func", "release")
	_, exists := inc.interfaceNames[id]
	if !exists {
		logger.Info("No interface name in cache", "id", id, "interface", name)
		return
	}

	logger.Info("Remove interface name", "ID", id, "interface", name)
	delete(inc.interfaceNames, id)
	inc.nameGenerator.Release(name)
}
